\section{Volatility}
Volatility is a open source collection of tools used to extract digital
artefacts from memory.\footnote{https://github.com/volatilityfoundation/volatility} 
The framework is not meant for a live forensic analysis but an offline analysis
on memory acquired from a live machine or device, see Section \ref{lime} for
memory acquisition. Volatility has support for Windows, Mac OS, and Linux, and
from version 2.3 they also supported the ARM architecture, this is essential
for analysing memory on Android devices, as most devices that run Android has a
ARM architecture. With a memory dump Volatility can extract information such as
running processes, network connections, mounted devices and view the mapped
memory for processes and kernel modules. Volatility is especially useful when
analysing a system compromised by malware, as malware often hides itself in
memory to avoid detection. With Volatility the artefacts of the malware can be
found, and be analysed. \\

Volatility can also help when encryption is used on the device, if the device is
powered down the keys will be lost and you might be unable to use the data 
collected from a less volatile source such as a SD card or a hard drive. With
Volatility the keys can be extracted from the memory (if present), Volatility 
comes with a plugin that can be used to extract the key used by Truecrypt for 
disk encryption. In our case we wanted to see if we could find the encryption
key used by a popular SMS app to encrypt messages.\\

The easiest approach to the problem of finding data used by Android
applications is to go through the Dalvik VM as proposed by Case\cite{case2011}.
The Dalvik VM is the \textit{process virtual
machine}\footnote{https://en.wikipedia.org/wiki/Dalvik\_\%28software\%29} for
Android that is used to run Android application, applications are translated to
Dalvik bytecode. This makes the Dalvik VM a good entry point for analysing
applications. The first application that starts and runs in a Dalvik VM is the
\textit{zygote} process. It preloades and initializes classes that are shared
between different processes, it is also the process that will fork additional
Dalvik VMs if required. The Dalvik VM is implemented as a shared library which
is loaded dynamically by applications. This can be seen by the pstree and
proc\_maps plugins, see Appendix \ref{pstree} and \ref{procmaps}. \\

Since all the user applications on Android runs in a Dalvik VM it makes a good entry
point for forensic analysis, the source code is also publicly available. It is
written in C++, but makes use of simple C structures, which makes it easier to
locate them in memory compared to more complex structures such as classes. Case
and \cite{holger} shows that the \textit{DvmGlobals} structure which is
declared in \textit{dalvik/vm/Globals.h} contains a lot of information about
the application it is running. The \textit{loadedClasses} member is a pointer
to a hash table which contains the all the system classes, this makes it a
valuable structure because it can point us to where in memory information can
be found. 
%address space stuff here


