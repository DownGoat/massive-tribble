\section{Methodology and approach}
When dealing with evidence, you have to consider the order of volatility of
each component. Although memory is the most volatile compared to flash memory,
it is necessary to prioritize what information is most valuable to the forensic
investigation. By using the method presented in our paper, it is likely to
format /data and /system partitions of the flash memory. This changes the state
of evidence on a less volatile storage component that might have important
information stored. There should be procedures in place for each different type
of investigation to know what order evidence should be acquired. One example
could be in a child pornography case where evidence from the memory would be
highly valuable to find logs or accessed pictures, as opposed to investigation
into piracy of copyrighted material, where evidence is most likely to be larger
files in the non-volatile memory.\\

To keep chain of custody one should keep a timeline and log for every action
taken during the investigation. The chain of custody should among other things
include the names of the people working on the evidence, and  when an action
takes place, what impact this would have on the evidence. To keep the integrity
of the evidence, any work should always be done to a copy, and not on the
original evidence itself, as to keep the integrity of the original evidence.\\

For our experiments we did not have to take into account the order of
volatility, since we have focused on the memory part of the device only. During
a real forensic investigation, the order of volatility must be taken into
account., and using our method could have some impact on the other parts of the
device. In our experiments we preserve the integrity of the evidence (the
memory dumps) by only working on copies of the original evidence. The tools we
have used during our investigation are read-only tools, they do not write or
change the evidence. This means that every action we performed can be repeated
on any copy of the evidence.

%IN HERE! More stuff about the methodology in aquiring memory of a device (timelog, important shit to remember, chain of custody etc.)
\subsection{Methods to acquire memory}
We found several alternatives for acquisition of memory from Android devices.
\paragraph{dd on} \texttt{/dev/mem} is a very simple method for acquiring memory. But \texttt{/dev/mem} 
can only be used directly when the kernel is compiled with the \texttt{STRICT\_DEVMEM} flag off or with 
a kernel version pre 2.6. The first kernel version ever used on Android is version 2.6.25
\footnote{\url{http://elinux.org/Android\_Kernel\_Versions}}. There is also a problem with the dd 
application in Android devices, it can not handle file offsets above \texttt{0x80000000}\cite{acq_vol_android_mem}.
\paragraph{fmem} is a LKM (Loadable Kernel Module) which creates \texttt{/dev/fmem}. \texttt{/dev/fmem} 
is similar to \texttt{/dev/mem}, but without the limitations. However, there are some issues using 
fmem on Android devices running ARM including the problem with \texttt{dd} mentioned earlier \cite{acq_vol_android_mem}.
\paragraph{LiME LKM} (Linux Memory Extractor) LKM\footnote{\url{https://github.com/504ensicsLabs/LiME}} 
provides a forensically sound method for acquiring memory from memory \cite{heriyanto2013procedures}. 
LiME is formerly known as DMD (Droid Memory Dumpstr).
\paragraph{Chosen approach} For acquisition of memory we have chosen to use the LiME LKM because of 
the problems described with the other methods.
\subsection{Environment}
When starting the project we needed to decide weather to use an physical device 
or an emulator to conduct our experiment on. To make the experiment as close to 
reality as possible it should have been done on a physical device, however, an 
emulator gives us a close match to reality and is easily replicable. Also, by 
using an emulator we avoid rooting our own phones, thus we avoid voiding 
warranty. Also, we found a guide on the Volatility wiki
\footnote{\url{https://github.com/volatilityfoundation/volatility/wiki/Android}} 
for how to dump memory with an Android emulator. Therefore we chose to use an 
emulator. Some deviation from the guide was done to be able conduct the 
experiment, due to the fact that we were running on a Linux system, not Mac OS 
X as the guide uses. This mostly involves editing the paths in the Makefiles 
you are editing to fit your system. % teit setning?
A detailed guide on the setup can be found in the appendix \ref{guide}.\\

The emulator was set up on a computer running the latest Ubuntu (Ubuntu 14.04.1 LTS x86\_64).
its based on the Nexus 7 (2012) with Android 4.2.2 Jelly Bean 
(API level 17) and Linux Kernel 2.6.29. This was chosen because of convenience
since the guide we followed is using this kernel.
\subsection{Tools}
Strings is useful tool for getting all strings in a file, while hex editor gives a more detailed overview.
\paragraph{Volatility} is a open source collection of tools used to extract digital
  artefacts from memory.\footnote{\url{https://github.com/volatilityfoundation/volatility}} 
  The framework is not meant for a live forensic analysis but an offline analysis
  on memory acquired from a live machine or device. Volatility has support for Windows, Mac OS, and Linux, and
  from version 2.3 they also supported the ARM architecture, this is essential
  for analyzing memory on Android devices, as most devices that run Android has a
  ARM architecture. With a memory dump, Volatility can extract information such as
  running processes, network connections, mounted devices and view the mapped
  memory for processes and kernel modules. Volatility is especially useful when
  analyzing a system compromised by malware, as malware often hides itself in
  memory to avoid detection. With Volatility the artifacts of the malware can be
  found, and be analyzed. \\
  
  Volatility can also help when encryption is used on the device, if the device is
  powered down the keys will be lost and you might be unable to use the data 
  collected from a less volatile source such as a SD card or a hard drive. With
  Volatility the keys can be extracted from the memory (if present), Volatility 
  comes with a plugin that can be used to extract the key used by Truecrypt for 
  disk encryption. In our case we wanted to see if we could find the encryption
  key used by a popular SMS application, TextSecure, to encrypt messages.\\
  
  The easiest approach to the problem of finding data used by Android
  applications is to go through the Dalvik VM as proposed by Case\cite{case2011}.
  The Dalvik VM is the \textit{process virtual
  machine}\footnote{\url{https://en.wikipedia.org/wiki/Dalvik\_\%28software\%29}} for
  Android that is used to run Android application, applications are translated to
  Dalvik bytecode. This makes the Dalvik VM a good entry point for analyzing
  applications. The first application that starts and runs in a Dalvik VM is the
  \textit{zygote} process. It preloades and initializes classes that are shared
  between different processes, it is also the process that will fork additional
  Dalvik VMs if required. The Dalvik VM is implemented as a shared library which
  is loaded dynamically by applications. This can be seen by the \texttt{pstree} and
  \texttt{proc\_maps} plugins, see Appendix \ref{pstree} and \ref{procmaps}. \\

  Since all the user applications on Android runs in a Dalvik VM it makes a good entry
  point for forensic analysis, the source code is also publicly available. It is
  written in C++, but makes use of simple C structures, which makes it easier to
  locate them in memory compared to more complex structures such as classes. Case
  and \cite{holger} shows that the \textit{DvmGlobals} structure which is
  declared in \textit{dalvik/vm/Globals.h} contains a lot of information about
  the application it is running. The \textit{loadedClasses} member is a pointer
  to a hash table which contains all the system classes, this makes it a
  valuable structure because it can point us to where in memory information can
  be found.\\

  Volatility has a plugin interface for creating plugins. It is possible to
  invoke other plugins from your own, this means you can stitch together
  several other plugins to write your own. This makes it much easier to write
  plugins, since you do not have to reinvent the wheel for every plugin. There
  are plugins for analyzing the Dalvik VM, but they are very version specific.

  \paragraph{PhotoRec} is a file recovery tool that supports many platforms and file systems, including memory images. 
  It Can extract images, text files and more. %Mer p√• photorec

